from typing import Deque
from datetime import datetime
from collections import deque
from dataclasses import dataclass

from trade import Trade
from instrument import Instrument
from order import Order, OrderType, OrderSide



@dataclass
class Trade:
    """
    Represents an executed match between one buy order and one sell order.
    """
    buy_order_id: int
    sell_order_id: int
    instrument_code: str
    price: float
    amount: int
    timestamp: datetime

class OrderBook:
    """
    Maintains bids (buy orders) and asks (sell orders) for a specific instrument.
    Enforces price-time priority. Generates Trades upon successful matches.
    """

    def __init__(self, instrument: Instrument) -> None:
        self.instrument: Instrument = instrument
        self.bids: Deque[tuple[float, datetime, Order]] = deque()
        self.asks: Deque[tuple[float, datetime, Order]] = deque()
        self.trades: list[Trade] = []

    def add_order(self, incoming_order: Order) -> list[Trade]:
        """
        Main entry point: match incoming_order against the order book.
        Returns a list of Trades generated by this matching operation.
        """
        if incoming_order.instrument != self.instrument:
            raise ValueError("Incoming order instrument does not match this OrderBook.")

        if incoming_order.side == OrderSide.BUY:
            return self._match_buy_order(incoming_order)
        elif incoming_order.side == OrderSide.SELL:
            return self._match_sell_order(incoming_order)

    def _match_buy_order(self, buy_order: Order) -> list[Trade]:
        trades: list[Trade] = []
        # MARKET buy => check liquidity first
        if buy_order.order_type == OrderType.MARKET:
            if not self._has_sufficient_liquidity(buy_order, side="ASK"):
                return trades  # reject if no sufficient volume

        trades = self._execute_buy_matches(buy_order)

        # Insert leftover LIMIT buy
        if buy_order.amount > 0 and buy_order.order_type == OrderType.LIMIT:
            self._insert_bid(buy_order)

        return trades

    def _match_sell_order(self, sell_order: Order) -> list[Trade]:
        trades: list[Trade] = []
        # MARKET sell => check liquidity
        if sell_order.order_type == OrderType.MARKET:
            if not self._has_sufficient_liquidity(sell_order, side="BID"):
                return trades

        trades = self._execute_sell_matches(sell_order)

        # Insert leftover LIMIT sell
        if sell_order.amount > 0 and sell_order.order_type == OrderType.LIMIT:
            self._insert_ask(sell_order)

        return trades

    def _execute_buy_matches(self, buy_order: Order) -> list[Trade]:
        trades: list[Trade] = []
        while buy_order.amount > 0 and self.asks:
            best_ask_price, ask_arrival_time, ask_order = self.asks[0]

            # For LIMIT, price must be >= best ask
            if (buy_order.order_type == OrderType.MARKET
                    and best_ask_price > (buy_order.price or 0)):
                break

            matched_amount = min(buy_order.amount, ask_order.amount)
            execution_price = best_ask_price

            new_trade = Trade(
                buy_order_id=buy_order.id,
                sell_order_id=ask_order.id,
                instrument_code=self.instrument.code,
                price=execution_price,
                amount=matched_amount,
                timestamp=datetime.now()
            )
            self.trades.append(new_trade)
            trades.append(new_trade)

            buy_order.amount -= matched_amount
            ask_order.amount -= matched_amount

            if ask_order.amount == 0:
                self.asks.popleft()
            else:
                self.asks[0] = (best_ask_price, ask_arrival_time, ask_order)

            if buy_order.amount == 0:
                break

        return trades

    def _execute_sell_matches(self, sell_order: Order) -> list[Trade]:
        trades: list[Trade] = []
        while sell_order.amount > 0 and self.bids:
            best_bid_price, bid_arrival_time, bid_order = self.bids[0]

            if (sell_order.order_type == OrderType.LIMIT
                    and best_bid_price < (sell_order.price or 0)):
                break

            matched_amount = min(sell_order.amount, bid_order.amount)
            execution_price = best_bid_price

            new_trade = Trade(
                buy_order_id=bid_order.id,
                sell_order_id=sell_order.id,
                instrument_code=self.instrument.code,
                price=execution_price,
                amount=matched_amount,
                timestamp=datetime.now()
            )
            self.trades.append(new_trade)
            trades.append(new_trade)

            sell_order.amount -= matched_amount
            bid_order.amount -= matched_amount

            if bid_order.amount == 0:
                self.bids.popleft()
            else:
                self.bids[0] = (best_bid_price, bid_arrival_time, bid_order)

            if sell_order.amount == 0:
                break

        return trades

    def _insert_bid(self, order: Order) -> None:
        entry: tuple[float, datetime, Order] = (order.price or 0.0, order.timestamp or datetime.now(), order)
        inserted: bool = False

        for i, (price, arr_time, existing) in enumerate(self.bids):
            # Higher price => earlier in the list
            if price < order.price:
                self.bids.insert(i, entry)
                inserted = True
                break
            # If prices tie, we proceed to insert behind them (FIFO)
        if not inserted:
            self.bids.append(entry)

    def _insert_ask(self, order: Order) -> None:
        entry: tuple[float, datetime, Order] = (order.price or 0.0, order.timestamp or datetime.now(), order)
        inserted: bool = False

        for i, (price, arr_time, existing) in enumerate(self.asks):
            if price > order.price:
                self.asks.insert(i, entry)
                inserted = True
                break
            # If same price, keep FIFO
        if not inserted:
            self.asks.append(entry)

    def _has_sufficient_liquidity(self, incoming_order: Order, side: str) -> bool:
        total_liquidity: int = 0
        needed: int = incoming_order.amount

        if side == "ASK":
            for (ask_price, arr_time, ask_order) in self.asks:
                total_liquidity += ask_order.amount
                if total_liquidity >= needed:
                    return True
        else:  # side == "BID"
            for (bid_price, arr_time, bid_order) in self.bids:
                total_liquidity += bid_order.amount
                if total_liquidity >= needed:
                    return True

        return False

    def get_best_bid(self) -> tuple[float, datetime, Order] | None:
        return self.bids[0] if self.bids else None

    def get_best_ask(self) -> tuple[float, datetime, Order] | None:
        return self.asks[0] if self.asks else None
